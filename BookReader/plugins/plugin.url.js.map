{"version":3,"sources":["webpack://@internetarchive/bookreader/./src/js/plugins/plugin.url.js"],"names":["super_","extend","BookReader","defaultOptions","enableUrlPlugin","bookId","defaults","updateWindowTitle","urlMode","urlHistoryBasePath","urlTrackedParams","urlTrackIndex0","prototype","setup","options","call","this","locationPollId","oldLocationHash","oldUserHash","init","bind","eventNames","PostInit","document","title","shortTitle","urlStartLocationPolling","fragmentChange","urlUpdateFragment","maximumCharacters","bookTitle","length","substr","urlReadFragment","clearInterval","locationPollID","setInterval","newFragment","params","paramsFromFragment","updateParams","updateFromParams","trigger","stop","animating","autoStop","animationFinishedCallback","allParams","paramsFromCurrent","index","page","reduce","validParams","paramName","fragmentFromParams","currFragment","currQueryString","getLocationSearch","newQueryString","queryStringFromParams","window","history","replaceState","baseWithoutSlash","replace","newFragmentWithSlash","newUrlPath","newQueryStringSearch","urlParamsFiltersOnlySearch","readQueryString","location","url","URLSearchParams","has","q","get","pathname","hash","urlReadHashFragment"],"mappings":"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","file":"plugins/plugin.url.js","sourcesContent":["/* global BookReader */\n/**\n * Plugin for URL management in BookReader\n * Note read more about the url \"fragment\" here:\n * https://openlibrary.org/dev/docs/bookurls\n */\n\njQuery.extend(BookReader.defaultOptions, {\n  enableUrlPlugin: true,\n  bookId: '',\n  /** @type {string} Defaults can be a urlFragment string */\n  defaults: null,\n  updateWindowTitle: false,\n\n  /** @type {'history' | 'hash'} */\n  urlMode: 'hash',\n\n  /**\n   * When using 'history' mode, this part of the URL is kept constant\n   * @example /details/plato/\n   */\n  urlHistoryBasePath: '/',\n\n  /** Only these params will be reflected onto the URL */\n  urlTrackedParams: ['page', 'search', 'mode', 'region', 'highlight'],\n\n  /** If true, don't update the URL when `page == n0 (eg \"/page/n0\")` */\n  urlTrackIndex0: false,\n});\n\n/** @override */\nBookReader.prototype.setup = (function(super_) {\n  return function(options) {\n    super_.call(this, options);\n\n    this.bookId = options.bookId;\n    this.defaults = options.defaults;\n\n    this.locationPollId = null;\n    this.oldLocationHash = null;\n    this.oldUserHash = null;\n  };\n})(BookReader.prototype.setup);\n\n/** @override */\nBookReader.prototype.init = (function(super_) {\n  return function() {\n\n    if (this.options.enableUrlPlugin) {\n      this.bind(BookReader.eventNames.PostInit, () => {\n        const { updateWindowTitle, urlMode } = this.options;\n        if (updateWindowTitle) {\n          document.title = this.shortTitle(50);\n        }\n        if (urlMode === 'hash') {\n          this.urlStartLocationPolling();\n        }\n      });\n\n      this.bind(BookReader.eventNames.fragmentChange,\n        this.urlUpdateFragment.bind(this)\n      );\n    }\n    super_.call(this);\n  };\n})(BookReader.prototype.init);\n\n/**\n * Returns a shortened version of the title with the maximum number of characters\n * @param {number} maximumCharacters\n * @return {string}\n */\nBookReader.prototype.shortTitle = function(maximumCharacters) {\n  if (this.bookTitle.length < maximumCharacters) {\n    return this.bookTitle;\n  }\n\n  const title = `${this.bookTitle.substr(0, maximumCharacters - 3)}...`;\n  return title;\n};\n\n/**\n * Starts polling of window.location to see hash fragment changes\n */\nBookReader.prototype.urlStartLocationPolling = function() {\n  this.oldLocationHash = this.urlReadFragment();\n\n  if (this.locationPollId) {\n    clearInterval(this.locationPollID);\n    this.locationPollId = null;\n  }\n\n  const updateHash = () => {\n    const newFragment = this.urlReadFragment();\n    const hasFragmentChange = (newFragment != this.oldLocationHash) && (newFragment != this.oldUserHash);\n\n    if (!hasFragmentChange) { return; }\n\n    const params = this.paramsFromFragment(newFragment);\n\n    const updateParams = () => this.updateFromParams(params);\n\n    this.trigger(BookReader.eventNames.stop);\n    if (this.animating) {\n      // Queue change if animating\n      if (this.autoStop) this.autoStop();\n      this.animationFinishedCallback = updateParams;\n    } else {\n      // update immediately\n      updateParams();\n    }\n    this.oldUserHash = newFragment;\n  }\n\n  this.locationPollId = setInterval(updateHash, 500);\n};\n\n/**\n * Update URL from the current parameters.\n * Call this instead of manually using window.location.replace\n */\nBookReader.prototype.urlUpdateFragment = function() {\n  const allParams = this.paramsFromCurrent();\n  const { urlMode, urlTrackIndex0, urlTrackedParams } = this.options;\n\n  if (!urlTrackIndex0\n      && (typeof(allParams.index) !== 'undefined')\n      && allParams.index === 0) {\n    delete allParams.index;\n    delete allParams.page;\n  }\n\n  const params = urlTrackedParams.reduce((validParams, paramName) => {\n    if (paramName in allParams) {\n      validParams[paramName] = allParams[paramName];\n    }\n    return validParams\n  }, {});\n\n  const newFragment = this.fragmentFromParams(params, urlMode);\n  const currFragment = this.urlReadFragment();\n  const currQueryString = this.getLocationSearch();\n  const newQueryString = this.queryStringFromParams(params, currQueryString, urlMode);\n  if (currFragment === newFragment && currQueryString === newQueryString) {\n    return;\n  }\n\n  if (urlMode === 'history') {\n    if (window.history && window.history.replaceState) {\n      const baseWithoutSlash = this.options.urlHistoryBasePath.replace(/\\/+$/, '');\n      const newFragmentWithSlash = newFragment === '' ? '' : `/${newFragment}`;\n\n      const newUrlPath = `${baseWithoutSlash}${newFragmentWithSlash}${newQueryString}`;\n      window.history.replaceState({}, null, newUrlPath);\n      this.oldLocationHash = newFragment + newQueryString;\n\n    }\n  } else {\n    const newQueryStringSearch = this.urlParamsFiltersOnlySearch(this.readQueryString());\n    window.location.replace('#' + newFragment + newQueryStringSearch);\n    this.oldLocationHash = newFragment + newQueryStringSearch;\n\n  }\n};\n\n/**\n * @private\n * Filtering query parameters to select only book search param (?q=foo)\n   This needs to be updated/URL system modified if future query params are to be added\n * @param {string} url\n * @return {string}\n * */\nBookReader.prototype.urlParamsFiltersOnlySearch = function(url) {\n  const params = new URLSearchParams(url);\n  return params.has('q') ? `?${new URLSearchParams({ q: params.get('q') })}` : '';\n}\n\n\n/**\n * Will read either the hash or URL and return the bookreader fragment\n * @return {string}\n */\nBookReader.prototype.urlReadFragment = function() {\n  const { urlMode, urlHistoryBasePath } = this.options;\n  if (urlMode === 'history') {\n    return window.location.pathname.substr(urlHistoryBasePath.length);\n  } else {\n    return window.location.hash.substr(1);\n  }\n};\n\n/**\n * Will read the hash return the bookreader fragment\n * @return {string}\n */\nBookReader.prototype.urlReadHashFragment = function() {\n  return window.location.hash.substr(1);\n};\n"],"sourceRoot":""}