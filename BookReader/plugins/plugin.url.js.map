{"version":3,"sources":["webpack://@internetarchive/bookreader/./src/js/plugins/plugin.url.js"],"names":["super_","jQuery","extend","BookReader","defaultOptions","enableUrlPlugin","bookId","defaults","updateWindowTitle","urlMode","urlHistoryBasePath","urlTrackedParams","urlTrackIndex0","prototype","setup","options","call","this","locationPollId","oldLocationHash","oldUserHash","init","bind","eventNames","PostInit","document","title","shortTitle","urlStartLocationPolling","fragmentChange","urlUpdateFragment","maximumCharacters","bookTitle","length","substr","urlReadFragment","clearInterval","locationPollID","setInterval","newFragment","params","paramsFromFragment","updateParams","updateFromParams","trigger","stop","animating","autoStop","animationFinishedCallback","allParams","paramsFromCurrent","index","page","reduce","validParams","paramName","fragmentFromParams","currFragment","currQueryString","getLocationSearch","newQueryString","queryStringFromParams","window","history","replaceState","baseWithoutSlash","replace","newFragmentWithSlash","newUrlPath","newQueryStringSearch","urlParamsFiltersOnlySearch","readQueryString","location","url","URLSearchParams","has","q","get","pathname","hash"],"mappings":"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","file":"plugins/plugin.url.js","sourcesContent":["/* global BookReader */\r\n/**\r\n * Plugin for URL management in BookReader\r\n * Note read more about the url \"fragment\" here:\r\n * https://openlibrary.org/dev/docs/bookurls\r\n */\r\n\r\njQuery.extend(BookReader.defaultOptions, {\r\n  enableUrlPlugin: true,\r\n  bookId: '',\r\n  /** @type {string} Defaults can be a urlFragment string */\r\n  defaults: null,\r\n  updateWindowTitle: false,\r\n\r\n  /** @type {'history' | 'hash'} */\r\n  urlMode: 'hash',\r\n\r\n  /**\r\n   * When using 'history' mode, this part of the URL is kept constant\r\n   * @example /details/plato/\r\n   */\r\n  urlHistoryBasePath: '/',\r\n\r\n  /** Only these params will be reflected onto the URL */\r\n  urlTrackedParams: ['page', 'search', 'mode', 'region', 'highlight'],\r\n\r\n  /** If true, don't update the URL when `page == n0 (eg \"/page/n0\")` */\r\n  urlTrackIndex0: false,\r\n});\r\n\r\n/** @override */\r\nBookReader.prototype.setup = (function(super_) {\r\n  return function(options) {\r\n    super_.call(this, options);\r\n\r\n    this.bookId = options.bookId;\r\n    this.defaults = options.defaults;\r\n\r\n    this.locationPollId = null;\r\n    this.oldLocationHash = null;\r\n    this.oldUserHash = null;\r\n  };\r\n})(BookReader.prototype.setup);\r\n\r\n/** @override */\r\nBookReader.prototype.init = (function(super_) {\r\n  return function() {\r\n\r\n    if (this.options.enableUrlPlugin) {\r\n      this.bind(BookReader.eventNames.PostInit, () => {\r\n        const { updateWindowTitle, urlMode } = this.options;\r\n        if (updateWindowTitle) {\r\n          document.title = this.shortTitle(50);\r\n        }\r\n        if (urlMode === 'hash') {\r\n          this.urlStartLocationPolling();\r\n        }\r\n      });\r\n\r\n      this.bind(BookReader.eventNames.fragmentChange,\r\n        this.urlUpdateFragment.bind(this)\r\n      );\r\n    }\r\n    super_.call(this);\r\n  };\r\n})(BookReader.prototype.init);\r\n\r\n/**\r\n * Returns a shortened version of the title with the maximum number of characters\r\n * @param {number} maximumCharacters\r\n * @return {string}\r\n */\r\nBookReader.prototype.shortTitle = function(maximumCharacters) {\r\n  if (this.bookTitle.length < maximumCharacters) {\r\n    return this.bookTitle;\r\n  }\r\n\r\n  const title = `${this.bookTitle.substr(0, maximumCharacters - 3)}...`;\r\n  return title;\r\n};\r\n\r\n/**\r\n * Starts polling of window.location to see hash fragment changes\r\n */\r\nBookReader.prototype.urlStartLocationPolling = function() {\r\n  this.oldLocationHash = this.urlReadFragment();\r\n\r\n  if (this.locationPollId) {\r\n    clearInterval(this.locationPollID);\r\n    this.locationPollId = null;\r\n  }\r\n\r\n  const updateHash = () => {\r\n    const newFragment = this.urlReadFragment();\r\n    const hasFragmentChange = (newFragment != this.oldLocationHash) && (newFragment != this.oldUserHash);\r\n\r\n    if (!hasFragmentChange) { return; }\r\n\r\n    const params = this.paramsFromFragment(newFragment);\r\n\r\n    const updateParams = () => this.updateFromParams(params);\r\n\r\n    this.trigger(BookReader.eventNames.stop);\r\n    if (this.animating) {\r\n      // Queue change if animating\r\n      if (this.autoStop) this.autoStop();\r\n      this.animationFinishedCallback = updateParams;\r\n    } else {\r\n      // update immediately\r\n      updateParams();\r\n    }\r\n    this.oldUserHash = newFragment;\r\n  }\r\n\r\n  this.locationPollId = setInterval(updateHash, 500);\r\n};\r\n\r\n/**\r\n * Update URL from the current parameters.\r\n * Call this instead of manually using window.location.replace\r\n */\r\nBookReader.prototype.urlUpdateFragment = function() {\r\n  const allParams = this.paramsFromCurrent();\r\n  const { urlMode, urlTrackIndex0, urlTrackedParams } = this.options;\r\n\r\n  if (!urlTrackIndex0\r\n      && (typeof(allParams.index) !== 'undefined')\r\n      && allParams.index === 0) {\r\n    delete allParams.index;\r\n    delete allParams.page;\r\n  }\r\n\r\n  const params = urlTrackedParams.reduce((validParams, paramName) => {\r\n    if (paramName in allParams) {\r\n      validParams[paramName] = allParams[paramName];\r\n    }\r\n    return validParams\r\n  }, {});\r\n\r\n  const newFragment = this.fragmentFromParams(params, urlMode);\r\n  const currFragment = this.urlReadFragment();\r\n  const currQueryString = this.getLocationSearch();\r\n  const newQueryString = this.queryStringFromParams(params, currQueryString, urlMode);\r\n  if (currFragment === newFragment && currQueryString === newQueryString) {\r\n    return;\r\n  }\r\n\r\n  if (urlMode === 'history') {\r\n    if (window.history && window.history.replaceState) {\r\n      const baseWithoutSlash = this.options.urlHistoryBasePath.replace(/\\/+$/, '');\r\n      const newFragmentWithSlash = newFragment === '' ? '' : `/${newFragment}`;\r\n\r\n      const newUrlPath = `${baseWithoutSlash}${newFragmentWithSlash}${newQueryString}`;\r\n      window.history.replaceState({}, null, newUrlPath);\r\n      this.oldLocationHash = newFragment + newQueryString;\r\n\r\n    }\r\n  } else {\r\n    const newQueryStringSearch = this.urlParamsFiltersOnlySearch(this.readQueryString());\r\n    window.location.replace('#' + newFragment + newQueryStringSearch);\r\n    this.oldLocationHash = newFragment + newQueryStringSearch;\r\n\r\n  }\r\n};\r\n\r\n/**\r\n * @private\r\n * Filtering query parameters to select only book search param (?q=foo)\r\n   This needs to be updated/URL system modified if future query params are to be added\r\n * @param {string} url\r\n * @return {string}\r\n * */\r\nBookReader.prototype.urlParamsFiltersOnlySearch = function(url) {\r\n  const params = new URLSearchParams(url);\r\n  return params.has('q') ? `?${new URLSearchParams({ q: params.get('q') })}` : '';\r\n}\r\n\r\n\r\n/**\r\n * Will read either the hash or URL and return the bookreader fragment\r\n * @return {string}\r\n */\r\nBookReader.prototype.urlReadFragment = function() {\r\n  const { urlMode, urlHistoryBasePath } = this.options;\r\n  if (urlMode === 'history') {\r\n    return window.location.pathname.substr(urlHistoryBasePath.length);\r\n  } else {\r\n    return window.location.hash.substr(1);\r\n  }\r\n};\r\n"],"sourceRoot":""}